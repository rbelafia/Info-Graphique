#include <Viewer.hpp>
#include "./../include/ShaderProgram.hpp"
#include "./../include/FrameRenderable.hpp"
#include "./../include/IndexedCubeRenderable.hpp"
#include "./../include/CubeRenderable.hpp"
#include "./../include/Renderable.hpp"
#include <glm/gtc/type_ptr.hpp>

#define SCR_WIDTH 1024
#define SCR_HEIGHT 768

int main( int argc, char* argv[] )
{
	// Stage 1: Create the window and its OpenGL context
	Viewer viewer(SCR_WIDTH, SCR_HEIGHT);

	// Stage 2: Load resources like shaders, meshes... and make them part of the virtual scene
	// ...
	
	// Path to the vertex shader glsl code
	std::string vShader = "./../../sfmlGraphicsPipeline/shaders/defaultVertex.glsl";
	// Path to the fragment shader glsl code
	std::string fShader = "./../../sfmlGraphicsPipeline/shaders/defaultFragment.glsl";
	// Compile and link the shaders into a program
	ShaderProgramPtr defaultShader = std::make_shared<ShaderProgram>(vShader, fShader);
	// Add the shader program to the Viewer
	viewer.addShaderProgram(defaultShader);

	// Shader program instantiation
	//ShaderProgramPtr flatShader = std::make_shared<ShaderProgram>(vShader, fShader);
	// When instantiating a renderable ,
	// you must specify the shader program used to draw it .
	FrameRenderablePtr frame = std::make_shared<FrameRenderable>(defaultShader);
	viewer.addRenderable(frame);

	// Instantiate a CubeRenderable while specifying its shader program
	CubeRenderablePtr cube = std::make_shared<CubeRenderable>(/*flatShader*/defaultShader);
	IndexedCubeRenderablePtr cubeIndex = std::make_shared<IndexedCubeRenderable>(/*flatShader*/defaultShader);

	//Renderable::setModel(cube);
	//glm::translate(cube, glm::vec4 (1 ,0 ,0, 1));
	cube->setModelMatrix(glm::translate(getModelMatrix,glm::vec3 (1 ,1 ,0)));

	
	// Add the renderable to the Viewer
	viewer.addRenderable ( cube );
	viewer.addRenderable ( cubeIndex );
	
	// Stage 3: Our program loop
	while( viewer.isRunning() )
	{
	    viewer.handleEvent(); 	// user interactivity (keyboard/mouse)
	    viewer.draw();		// rasterization (write in framebuffer)
	    viewer.display();		// refresh window
	}
	
	return EXIT_SUCCESS;
}
